#<center>C++虚基类的实现机制</center>

在《深度探索C++对象模型》里，有一个问题，也是去公司面试的时候那些技术人员常问的问题：在C++中，obj是一个类的对象，p是指向obj的指针，该类里面有个数据成员mem，请问obj.mem和p->mem在实现和效率上有什么不同。

答案是：只有一种情况下才有重大差异，该情况必须满足以下3个条件：

（1）、obj 是一个虚拟继承的派生类的对象  
（2）、mem是从虚拟基类派生下来的成员  
（3）、p是基类类型的指针

当这种情况下，p->mem会比obj.mem多了两个中间层。（也就是说在这种情况下，p->mem比obj.mem要明显的慢，呵呵）

1、**虚基类的使用，和为多态而实现的虚函数不同，是为了解决多重继承的二义性问题。**

举例如下：

<pre>
class A{
public:
    int a;
};

class B : virtual public A{
public:
   int b;
};

class C :virtual public A{
public:
   int c; 
};

class D : public B, public C{
public:
   int d;
};
</pre>

上面这种菱形的继承体系中，如果没有virtual继承，那么D中就有两个A的成员int a；继承下来，使用的时候，就会有很多二义性。而加了virtual继承，在D中就只有A的成员int a；的一份拷贝，该拷贝不是来自B，也不是来自C，而是一份单独的拷贝，那么，编译器是怎么实现的呢？？

在回答这个问题之前，先想一下，sizeof(A),sizeof(B),sizeof(C),sizeof(D)是多少？（在32位x86的linux2.6下面，或者在vc2005下面）

在linux2.6下面，结果如下：sizeof(A) = 4; sizeof(B) = 12; sizeof(C) = 12; sizeof(D) = 24

sizeof（B）为什么是12呢，那是因为多了一个指针（这一点和虚函数的实现一样），那个指针是干嘛的呢？

那么sizeof(D)为什么是24呢？那是因为除了继承B中的b，C中的c，A中的a,和D自己的成员d之外，还继承了B，C多出来的2个指针（B和C分别有一个）。再强调一遍，D中的int a不是来自B也不是来自C，而是另外的一份从A直接靠过来的成员。

<table border="2">
<tr>
  <td>vb_ptr: 继承自B的指针</td>
</tr>
<tr>
  <td>int b： 继承自B公有成员</td>
</tr>
<tr>
  <td>vc_ptr：继承自C的指针</td>
</tr>
<tr>
  <td>int c： 继承自C的共有成员</td>
</tr>
<tr>
  <td>int d： D自己的公有成员</td>
</tr>
<tr>
  <td>int a： 继承自A的公有成员</td>
</tr>
</table>

那么以下的用法会发生什么事呢？
<pre>
D dD;
B *pb = &dD;
pb->a;
</pre>

上面说过，dD中的int a不是继承自B的，也不是继承自C的，那么这个B中的pb->a又会怎么知道指向的是dD内存中的第六项呢？

那就是指针vb_ptr的妙用了。原理如下：

首先，vb_ptr指向一个整数的地址，里面放的整数是那个int a的距离dD开始处的位移（在这里vb_ptr指向的地址里面放的是20，以字节为单位）。编译器是这样做的：

首先，找到vb_ptr(这个不用找，因为在g++中，vb_ptr就是B*中的第一项，呵呵)，然后取得vb_ptr指向的地址的内容（这个例子是20），最后把这个内容与指针pb相加，就得到pb->a的地址了。

所以说这种时候，用指针转换多了两个中间层才能找到基类的成员，而且是运行期间。

由此也可以推知dD中的vb_ptr和vc_ptr的内容都是一样的，都是指向同一个地址，该地址就放20（在本例中）
<pre>
A *pa = &dD;
pa->a = 4;
</pre>
这个语句不用转换了，因为编译器在编译期间就知道他把A中的成员插在dD中的那个地方了（在本例中是末尾），所以这个语句中的运行效率和dD.a是一样的（至少也是差不多的）

这就是虚基类实现的基本原理。

注意的是：那些指针的位置和基类成员在派生类成员中的内存布局是不确定的，也就是说标准里面没有规定int a必须要放在最后，只不过g++编译器的实现而已。c++标准大概只规定了这套机制的原理，至于具体的实现，比如各成员的排放顺序和优化，由各个编译器厂商自己定~
#<center>c++虚函数实现机制</center>

__虚函数的作用：简单讲即实现多态。__

基类定义了虚函数，子类可以重写该函数，当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态地调用属于子类的该函数，且这样的函数调用是无法在编译器期间确认的，而是在运行期确认，也叫做迟绑定。

虚函数在c++中的实现机制就是用***虚表***和***虚指针***，但是具体是怎样的呢？从more effecive c++其中一篇文章里面可以知道：**是每个类用了一个虚表，每个类的对象用了一个虚指针。**具体的用法如下：

<pre>
class A{
public:
    virtual void f();
    virtual void g();
private:
    int a
};

class B : public A{
public:
    void g();
private:
    int b;
};
</pre>

因为A有virtual void f()，和virtual void g()，所以编译器为A类准备了一个虚表vtableA，内容如下：


<table border="2">
<tr>
  <td>A::f()的地址</td>
</tr>
<tr>
  <td>A::g()的地址</td>
</tr>
</table>

B因为继承了A，所以编译器也为B准备了一个虚表vtableB，内容如下：

<table border="2">
<tr>
  <td>A::f()的地址</td>
</tr>
<tr>
  <td>B::g()的地址</td>
</tr>
</table>

然后某处有语句 **B b;**的时候，编译器分配空间时，除了A的int a，B的成员int b；以外，还分配了一个虚指针vptr，指向B的虚表vtableB，b的布局如下：

<table border="2">
<tr>
  <td>vptr ： 指向B的虚表vtableB</td>
</tr>
<tr>
  <td>int a： 继承A的成员</td>
</tr>
<tr>
 <td>int b： B成员</td>
</tr>
</table>

当如下语句的时候：

A *pa = &b;

pa的结构就是A的布局（就是说用pa只能访问的到b对象的前两项，访问不到第三项int b）


那么pa->g()中，编译器知道的是，g是一个声明为virtual的成员函数，而且其入口地址放在表格（无论是vtalbeA表还是vtalbeB表）的第2项，那么编译器编译这条语句的时候就如是转换：call *(pa->vptr)[1]（C语言的数组索引从0开始哈~）。

这一项放的是B：：g()的入口地址，则就实现了多态。（注意b的vptr指向的是B的虚表vtableB）

另外要注意的是，如上的实现并不是唯一的，C++标准只要求用这种机制实现多态，至于虚指针vptr到底放在一个对象布局的哪里，标准没有要求，每个编译器自己决定。

2、两种多态实现机制及其优缺点

除了c++的这种多态的实现机制之外，还有另外一种实现机制，也是查表，不过是**按名称查表**，是smalltalk等语言的实现机制。这两种方法的优缺点如下：

（1）、按照绝对位置查表，这种方法由于编译阶段已经做好了索引和表项(如上面的call *(pa->vptr[1]） )，所以运行速度比较快;缺点是：当A的virtual成员比较多（比如1000个），而B重写的成员比较少（比如2个），这种时候，B的vtableＢ的剩下的998个表项都是放Ａ中的ｖｉｒｔｕａｌ成员函数的指针，如果这个派生体系比较大的时候，就浪费了很多的空间。

比如：ＧＵＩ库，以ＭＦＣ库为例，**ＭＦＣ有很多类，都是一个继承体系；而且很多时候每个类只是１，２个成员函数需要在派生类重写，如果用Ｃ＋＋的虚函数机制，每个类有一个虚表，每个表里面有大量的重复，就会造成空间利用率不高。于是ＭＦＣ的消息映射机制不用虚函数，而用第二种方法来实现多态**，那就是：

（２）、按照函数名称查表，这种方案可以避免如上的问题；但是由于要比较名称，有时候要遍历所有的继承结构，时间效率性能不是很高。

３、总结：

如果继承体系的基类的virtual成员不多，而且在派生类要重写的部分占了其中的大多数时候，用Ｃ＋＋的虚函数机制是比较好的；

但是如果继承体系的基类的virtual成员很多，或者是继承体系比较庞大的时候，而且派生类中需要重写的部分比较少，那就用名称查找表，这样效率会高一些，很多的ＧＵＩ库都是这样的，比如ＭＦＣ，ＱＴ

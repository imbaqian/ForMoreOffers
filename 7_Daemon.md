#<center>守护进程</center>

守护进程，也即通常所说的 Daemon 进程，是Linux下一种特殊的后台服务进程，它独立于控制终端并且周期性的执行某种任务或者等待处理某些发生的事件。守护进程通常在系统引导时启动，在系统关闭时终止。Linux系统下大多数服务都是通过守护进程实现的。守护进程的名称通常以d结尾，如httpd、crond、mysqld等。

####控制终端是什么？

终端是用户与操作系统进行交流的界面。在Linux系统中，用户由终端登陆系统后会得到一个shell进程，这个终端便成为这个shell进程的控制终端（Controlling Terminal）。shell进程启动的其他进程，由于复制了父进程的信息，因此也都同依附于这个控制终端。

从终端启动的进程都依附于该终端，并受终端控制和影响。终端关闭，相应的进程都会自动关闭。守护进程脱离终端的目的，也即是不受终端变化的影响不被终端打断，当然也不想在终端显示执行过程中的信息。

如果不想进程收到用户、终端或其他变化的影响，就必须把它编程守护进程。守护进程可以在Linux启动时从脚本 /etc/rc.d 启动，也可以由作业规划进程crond启动，还可以通过用户终端（shell）启动。

#如何实现守护进程

守护进程属于Linux进程管理的范畴。其首要的特性是后台运行，其次，要与从启动它的父进程的运行环境隔离开来，需要处理的内容大致包括会话、控制终端、进程组、文件描述符、文件权限掩码以及工作目录等。

实现一个守护进程，起始就是将普通进程按照上述特性改造为守护进程的过程。需要注意一点的是，不同版本的 Unix 其实现机制不同，BSD 和 Linux 下的实现细节就不同。根据上述的特性，我们便可以创建一个简单的守护进程，这里以Linux系统下 Shell 来启动为例。

##1.创建子进程，父进程退出

编写守护进程的第一步，就是要使得进程独立于终端后台运行。为避免终端挂起，将父进程退出，造成程序已经退出的假象，而后面的功能工作都在子进程完成，这样控制终端也可以继续执行其他命令，从而在形式上脱离控制终端的控制。

由于父进程先于子进程退出，子进程就变成孤儿进程，并由init进程作为其父进程收养。

##2.子进程创建新会话

进过上一步，子进程已经后台运行，然而系统调用fork创建子进程，子进程便复制了原父进程的进程控制块（PCB），相应地继承了一些信息，包括会话、进程组、控制终端等信息。尽管父进程已经退出，但子进程的会话、进程组、控制终端的信息没有改变。为使子进程完全拜托父进程的环境，需要调运setsid 函数。

会话和进程组：
- 会话：一个或多个进程组的集合。新建会话时，当前进程（会话中唯一的进程）成为会话首进程，也是当前进程组的组长进程，进程号为会话ID，同样也是该进程组的ID。它通常是登陆shell，也可以是调用setsid新建会话的孤儿进程。

- 进程组：一个或多个进程的集合。拥有唯一的标识进程组ID，每个进程组都有一个组长进程，该进程的进程号等于其进程组ID。进程组ID不会因组长进程退出而受到影响，fork 调用也不会改变进程组ID。
    
通常，会话开始于用户登录，终止于用户退出，期间的所有进程都属于这个会话。一个会话一般会包含一个会话首进程、一个前台进程组和一个后台进程组，控制端可有可无；此外，前台进程只有一个，后台进程组可以有多个，这些进程组共享一个控制终端。

- 前台进程组：该进程组中的进程可以向终端设备进行读、写操作（属于该组的进程可以从终端获得输入）。该进程组的 ID 等于控制终端进程组 ID ，通常据此来判断前台进程组。

- 后台进程组：会话除了会话层进程和前台进程组以外的所有进程，都属于后台进程组。该进程组中的进程只能向终端设备进行些操作。
   
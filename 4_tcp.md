#<center>TCP</center>

TCP头部数据格式如下：
![](/picture/tcp_head.png)

各个字段的信息说明如下：

* Source Port(Destination Port):分别占16位，表示源端口号和目的端口号；用于区别主机中的不同进程，源端口号和目的端口号配合上ip首部中的源io地址和mudi的ip地址就能唯一确定一个TCP连接；
* Sequence number:序列号用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题；
* Acknowledgment number:发送确认的一段所希望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加一。不过只有当标志位中的ACK标志为1时该确认序列号的字段才有效，该字段主要用来解决丢包问题。
* Data offset:用来标识TCP头部的长度，该数字为头部中字（32 bit）的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此tcp最多有60字节的头部。然而，没有任选字段，正常的长度是20字节；
* Reserved:3个保留位，留作以后使用，全部设置为0；
* Window size：窗口大小，也就是有名的 滑动窗口，用来进行流量控制；
* 标识位：tcp头部中共有9个标识位，用于操控TCP的状态，主要有URG，ACK，PSH，RST，SYN，FIN标识位的意思如下：
    * URG:表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；
    * ACK:表示应答域有效，就是前面所说的TCP应答号将会包含在TCP数据包中；
    * PSH:表示push操作，数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；
    * RST:表示复位请求，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；
    * SYN:表示同步序号，用来建立连接。SYN标识位和ACK标识位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；
    * FIN:表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了。
 
#三次握手协议！！！
 
TCP协议提供可靠的连接服务，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中。连接是通过三次握手进行初始化的，三次握手的过程如下:

![](/picture/three_hand_por.png)

前两次握手，客户端进入连接状态，后两次握手，服务器进入连接状态。所以三次握手后，一个全双工的连接就建立起来了，之后，客户端和服务器端就可以开始传送数据。

* 第一次握手：客户端发送请求报文段，将SYN位置为1，SeqNum为随机数A；
* 第二次握手：服务器返回ACK，确认收到客户端发来的SYN，然后设置AckNum为A+1，此外，服务器发送自己的连接请求报文段，即发送SYN和随机数B作为SeqNum；
* 第三次握手：客户端返回ACK，确认收到服务器发来的SYN，然后设置AckNum=B+1；

###**为什么需呀三次握手建立连接？**

简单来说，为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

考虑下面一种情况：client发出的第一个连接请求报文段并没有丢失，而是某个网络结点长时间滞留，以致延误到连接释放后的某个时间才到达server。server收到此失效的连接报文请求后，误以为是client发出的新的连接请求，于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在的client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却移位新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就浪费了。

采用“三次握手”的方法可以防止上述现象发生。

#四次握手断开连接

![](/picture\four_hand_duan.png)

客户端和服务器数据传送完毕后，需要断开TCP连接，断开连接的时候需要进行四次握手。

过程如下：
* 第一次握手：发起端发送FIN和SeqNum=A，进入FIN_WAIT_1状态，用来关闭发起端到接收端的数据传送，也就是告诉接收端：不会再给你发新数据了（当然，在FIN包之前发送出去的数据，如果没有收到ACK确认报文，发起端依然会重发这些数据），但此时发起端还可以接收数据；
* 第二次握手：接收端收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（AckNum = A + 1），此时接收端仍然可以给发起端发送数据（同意关闭连接请求，但是我还有数据需要传送，稍等...）；
* 第三次握手：接收端向发起端发送FIN，用来关闭到发起端的数据传送，也就是告诉发起端：我的数据也发送完了，不会再给你发数据了。此时接收端进入CLOSE_WAIT状态；
* 第四次握手：发起端发送ACK报文段，然后进入TIME_WAIT状态，接收端收到ACK报文段以后，就关闭连接。发起端等待2MSL（最大报文段生成时间）后依然没有收到回复，则证明server端已正常关闭，此时也可以关闭连接了。

如果要正确的理解四次断手的原理，还需要了解四次断手过程中的状态变化。

* FIN_WAIT_1:FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，他想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态。（主动方）
* FIN_WAIT_2:FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求断开连接，但另外还告诉对方，我暂时优点数据需要传送给你，稍后关闭连接。（主动方）
* CLOSE_WAIT:在CLOSE_WAIT状态下，需要完成的事情是 **等待你去关闭连接**。（被动方）
* LAST_ACK：被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。（被动方）
* TIME_WAIT：表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志时，可以直接进入到TIME_WAIT状态，而无需经过FIN_WAIT_2状态。（主动方）
* CLOSED：表示连接中断。

##为什么要四次握手断开协议

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。

#TCP重传机制

TCP要保证所有的数据包都可以到达，所以必须要有重传机制。

注意，接收端给发送端的ACK确认只会确认最后一个连续的包，比如，发送了1，2，3，4，5一共五分数据，接收端收到了1，2于是回ACK 3，然后收到了4（注意此时3会没收到），此时的TCP会怎么办？

我们要知道，SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。

##超时重传机制

每次发送数据包时，发送的数据报都有seqnum，接收端接收到数据后，会回复ack进行确认，表示某一seqnum数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。

针对上面的情况，接收端不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack回4，意味着3和4都收到了。但是这种方法有比较严重的问题，那就是应为要死等3，所以会导致4和5即便已经收到了，而发送放也不知道发生什么事，因为没有收到ack，所以发送方可能会悲观地认为4，5也丢了，所以可能导致4和5也重传。

##快速重传机制

接收数据一方发现有数据包丢掉了，就会发送ack报文告诉发送端重传丢失的报文，如果发送端连续收到标号相同的ack包，则会触发客户端的快速重传。比较超时重传和快速重传，可以发现超时重传是发送端在傻等着超时，然后触发重传；而快速重传则是接收端主动告诉发送端数据没有收到，然后触发发送端重传。

比如：如果发送方发出了1，2，3，4，5 份数据，第一份先送到，于是就ack回2，结果2因为某些原因没有收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重传2.然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。

#TCP滑动窗口

TCP里有一个字段叫Window，又叫Advertised-Window，这个字段是 **接收端告诉发送端自己还有多少缓冲区可以接收数据。**于是发送端就可以更具这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口是提高TCP传输效率的一种机制。流量控制只关注发送端和接收端自身的状况，而没有考虑整个网络的通信状况。

TCP缓冲区的一些数据结构：
![](/picture/advertised-window.png)

上图中我们可以看到：
* 接收端LastByteRead指向了TCP缓冲区中读到的位置，  
  NextByteExpected指向的地方是收到的连续包的最后一个位置 ，  
  LastByteRevd指向的是收到的包的最后一个位置，  
  我们可以看到中间有些数据还没有到达，所以有数据空白区。
* 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），  
  LastByteSent表示发出取了，但没有收到成功确认的Ack，  
  LastByteWritten指向的是上层应用正在写的地方。

于是：
* 接收端在给发送端回ack中会汇报自己的Advertised-window = MaxRcvBuff - LastByteRcvd - 1；
* 而发送方会根据这个窗口来靠能够只发送数据的大小，以保证接收方可以处理。

下面我们看看滑动窗口示意图：

![](/picture/滑动窗口示意图.png)

上图中分成了四个部分，分别是：（黑色窗口是滑动窗口）

1. 发送，并且已收到ack确认的数据。
2. 发送，但还没有收到ack确认的。
3. 在窗口中还没有发出去的（接收方还有空间）。
4. 窗口以外的数据（接收方没空间）。



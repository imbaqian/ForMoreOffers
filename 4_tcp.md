#<center>TCP</center>

TCP头部数据格式如下：
![](/picture/tcp_head.png)

各个字段的信息说明如下：

* Source Port(Destination Port):分别占16位，表示源端口号和目的端口号；用于区别主机中的不同进程，源端口号和目的端口号配合上ip首部中的源io地址和mudi的ip地址就能唯一确定一个TCP连接；
* Sequence number:序列号用来标识从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文段中的第一个数据字节在数据流中的序号，主要用来解决网络报乱序的问题；
* Acknowledgment number:发送确认的一段所希望收到的下一个序号，因此，确认序号应当是上次已成功收到数据字节序号加一。不过只有当标志位中的ACK标志为1时该确认序列号的字段才有效，该字段主要用来解决丢包问题。
* Data offset:用来标识TCP头部的长度，该数字为头部中字（32 bit）的数目，需要这个值是因为任选字段的长度是可变的。这个字段占4bit，因此tcp最多有60字节的头部。然而，没有任选字段，正常的长度是20字节；
* Reserved:3个保留位，留作以后使用，全部设置为0；
* Window size：窗口大小，也就是有名的 滑动窗口，用来进行流量控制；
* 标识位：tcp头部中共有9个标识位，用于操控TCP的状态，主要有URG，ACK，PSH，RST，SYN，FIN标识位的意思如下：
    * URG:表示TCP包的紧急指针域有效，用来保证TCP连接不被中断，并且督促中间层设备要尽快处理这些数据；
    * ACK:表示应答域有效，就是前面所说的TCP应答号将会包含在TCP数据包中；
    * PSH:表示push操作，数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；
    * RST:表示复位请求，用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；
    * SYN:表示同步序号，用来建立连接。SYN标识位和ACK标识位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1；
    * FIN:表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了。
 
#三次握手协议！！！
 
TCP协议提供可靠的连接服务，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。在TCP/IP协议中。连接是通过三次握手进行初始化的，三次握手的过程如下:

![](/picture/three_hand_por.png)

前两次握手，客户端进入连接状态，后两次握手，服务器进入连接状态。所以三次握手后，一个全双工的连接就建立起来了，之后，客户端和服务器端就可以开始传送数据。

* 第一次握手：客户端发送请求报文段，将SYN位置为1，SeqNum为随机数A；
* 第二次握手：服务器返回ACK，确认收到客户端发来的SYN，然后设置AckNum为A+1，此外，服务器发送自己的连接请求报文段，即发送SYN和随机数B作为SeqNum；
* 第三次握手：客户端返回ACK，确认收到服务器发来的SYN，然后设置AckNum=B+1；

###**为什么需呀三次握手建立连接？**

简单来说，为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

考虑下面一种情况：client发出的第一个连接请求报文段并没有丢失，而是某个网络结点长时间滞留，以致延误到连接释放后的某个时间才到达server。server收到此失效的连接报文请求后，误以为是client发出的新的连接请求，于是就向client发出确认报文段，同意建立连接。

假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在的client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却移位新的连接已经建立，并一直等待client发来数据。这样，server的很多资源就浪费了。

采用“三次握手”的方法可以防止上述现象发生。

#四次握手断开连接

![](/picture\four_hand_duan.png)
